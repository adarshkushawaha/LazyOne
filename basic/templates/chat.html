{% extends 'base.html' %}

{% block title %}Chat for: {{ conversation.task.title }}{% endblock %}

{% block content %}
<style>
    .chat-container { height: 75vh; display: flex; flex-direction: column; }
    .message-list { flex-grow: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 1.5rem; }
    .message { max-width: 75%; padding: 0.75rem 1rem; border-radius: 1.25rem; display: flex; flex-direction: column; line-height: 1.5; }
    .message.me { background-color: #06b6d4; /* cyan-600 */ color: white; align-self: flex-end; border-bottom-right-radius: 0.5rem; }
    .message.other { background-color: #374151; /* gray-700 */ color: #d1d5db; /* gray-300 */ align-self: flex-start; border-bottom-left-radius: 0.5rem; }
    .message-author { font-weight: 600; font-size: 0.875rem; margin-bottom: 0.25rem; color: #9ca3af; /* gray-400 */ }
    .message.me .message-author { color: #cffafe; /* cyan-100 */ }
    .message-content { margin: 0; font-size: 1rem; }
    .message-timestamp { font-size: 0.75rem; color: #6b7280; /* gray-500 */ text-align: right; margin-top: 0.5rem; }
    .message.me .message-timestamp { color: #a5f3fc; /* cyan-200 */ }
    .message-wrapper { display: flex; gap: 0.75rem; max-width: 80%; }
    .message-wrapper.me { align-self: flex-end; flex-direction: row-reverse; }
    .message-wrapper.other { align-self: flex-start; }
    .avatar { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; background-color: #4b5563; }
</style>

<div class="chat-container">
    <div class="border-b border-gray-700/50 pb-4 mb-4">
        <h2 class="text-xl font-bold text-white">Chat for: {{ conversation.task.title }}</h2>
        <p class="text-sm text-gray-400">
            With:
            {% for participant in conversation.participants.all %}
                {% if participant.id != request.user.id %}
                    {{ participant.username }}
                {% endif %}
            {% endfor %}
        </p>
    </div>

    <div class="message-list" id="message-list">
        <p id="loading-messages" class="text-center text-gray-400">Loading chat...</p>
    </div>

    <form class="mt-4 flex items-center space-x-3" id="message-form">
        <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required class="flex-grow w-full px-4 py-3 bg-gray-700/50 border border-gray-600/50 rounded-full text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-400 transition-shadow duration-200">
        <button type="submit" id="message-submit" class="flex-shrink-0 bg-cyan-500 hover:bg-cyan-600 text-white font-bold rounded-full h-12 w-12 flex items-center justify-center transition-colors">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
        </button>
    </form>
</div>

<!-- Include Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-firestore.js"></script>

<script>
    // Securely initialize Firebase from backend context
    var firebaseConfig = {
        apiKey: "{{ FIREBASE_API_KEY }}",
        authDomain: "{{ FIREBASE_AUTH_DOMAIN }}",
        projectId: "{{ FIREBASE_PROJECT_ID }}",
        storageBucket: "{{ FIREBASE_STORAGE_BUCKET }}",
        messagingSenderId: "{{ FIREBASE_MESSAGING_SENDER_ID }}",
        appId: "{{ FIREBASE_APP_ID }}"
    };
    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    } else {
        firebase.app();
    }

    const db = firebase.firestore();
    const conversationId = "{{ conversation.id }}";
    const currentUser = {
        username: "{{ request.user.username }}",
        id: "{{ request.user.id }}"
    };

    const messageList = document.getElementById('message-list');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const messageSubmitButton = document.getElementById('message-submit');
    const loadingIndicator = document.getElementById('loading-messages');

    // Cache for user profiles to avoid re-fetching
    const userProfileCache = {};

    // --- Firestore Real-Time Listener ---
    const messagesRef = db.collection('conversations').doc(conversationId).collection('messages').orderBy('timestamp');

    messagesRef.onSnapshot(snapshot => {
        loadingIndicator.style.display = 'none';
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const data = change.doc.data();
                fetchUserAndRenderMessage(data);
            }
        });
        scrollToBottom();
    }, error => {
        console.error("Error listening for messages: ", error);
        loadingIndicator.textContent = "Error loading chat. Please refresh.";
    });

    // --- Form Submission ---
    messageForm.addEventListener('submit', function(e) {
        e.preventDefault();
        const messageContent = messageInput.value;
        if (messageContent.trim() === '' || messageSubmitButton.disabled) return;

        messageSubmitButton.disabled = true;
        messageSubmitButton.classList.add('opacity-50');

        // Add a new message to Firestore
        db.collection('conversations').doc(conversationId).collection('messages').add({
            content: messageContent,
            authorId: currentUser.id,
            authorUsername: currentUser.username,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        }).catch(error => {
            console.error("Error sending message: ", error);
            alert("Could not send message.");
        });

        messageInput.value = ''; // Clear input immediately for better UX
        setTimeout(() => { // Re-enable button after a short delay
            messageSubmitButton.disabled = false;
            messageSubmitButton.classList.remove('opacity-50');
        }, 1000);
    });

    // --- Utility Functions ---
    async function fetchUserAndRenderMessage(messageData) {
        const authorId = messageData.authorId;
        let userProfile = userProfileCache[authorId];

        if (!userProfile) {
            try {
                const userDoc = await db.collection('users').doc(authorId).get();
                if (userDoc.exists) {
                    userProfile = userDoc.data();
                    userProfileCache[authorId] = userProfile; // Cache the result
                }
            } catch (e) {
                console.error("Could not fetch user profile:", e);
            }
        }
        
        // Use a fallback profile if fetch fails or user doesn't exist in 'users' collection
        userProfile = userProfile || { username: messageData.authorUsername, avatarUrl: null };
        renderMessage(messageData, userProfile);
    }

    function renderMessage(messageData, authorProfile) {
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${messageData.authorId == currentUser.id ? 'me' : 'other'}`;

        const avatarUrl = authorProfile.avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(authorProfile.username)}&background=random`;

        const timeAgo = messageData.timestamp ? timeSince(new Date(messageData.timestamp.seconds * 1000)) : 'just now';

        wrapper.innerHTML = `
            <img src="${avatarUrl}" alt="${authorProfile.username}" class="avatar">
            <div class="message ${messageData.authorId == currentUser.id ? 'me' : 'other'}" data-timestamp="${messageData.timestamp ? messageData.timestamp.seconds : ''}">
                <p class="message-author">${authorProfile.username}</p>
                <p class="message-content">${messageData.content}</p>
                <p class="message-timestamp">${timeAgo}</p>
            </div>
        `;
        messageList.appendChild(wrapper);
    }

    function scrollToBottom() {
        messageList.scrollTop = messageList.scrollHeight;
    }

    function timeSince(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " years ago";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " months ago";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " days ago";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " hours ago";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " minutes ago";
        return "just now";
    }

    // --- Real-time Timestamp Updater ---
    function updateTimestamps() {
        const messages = document.querySelectorAll('.message[data-timestamp]');
        messages.forEach(msg => {
            const timestamp = parseFloat(msg.dataset.timestamp);
            if (timestamp) {
                const timeAgo = timeSince(new Date(timestamp * 1000));
                const timestampEl = msg.querySelector('.message-timestamp');
                if (timestampEl) timestampEl.textContent = timeAgo;
            }
        });
    }
    setInterval(updateTimestamps, 60000); // Update every minute

</script>

{% endblock %}
